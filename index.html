<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hourly Case Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { box-sizing: border-box; }
body { font-family: Arial; background: #0f172a; color: #e5e7eb; padding: 20px; }
input, button, select { width: 100%; padding: 10px; margin: 6px 0; font-size: 16px; }
button { background: #2563eb; color: white; border: none; border-radius: 6px; }
button.reset { background: #dc2626; }
.card { background: #020617; padding: 15px; border-radius: 10px; margin-bottom: 15px; }
.log { border-top: 1px solid #334155; margin-top: 10px; padding-top: 10px; }
.log-entry { margin-bottom: 6px; }
small { color: #94a3b8; }
</style>
</head>
<body>

<h1>Hourly Case Tracker</h1>

<div class="card">
  <h3>Line Selection</h3>
  <select id="lineSelect" onchange="lineChanged()">
    <option value="">-- Select Line --</option>
  </select>
  <input id="newLine" placeholder="New Line Name / Number">
  <button onclick="addLine()">Add Line</button>
  <button onclick="deleteLine()" class="reset">Delete Line</button>
</div>

<div class="card">
  <h3>Run Setup</h3>
  <input id="material" placeholder="Material Code">
  <input id="startCount" type="number" placeholder="Starting Case Count">
  <button onclick="startRun()">Start Run</button>
</div>

<div class="card">
  <h3>Hourly Entry</h3>
  <input id="time" placeholder="Time (7am, 7:30)">
  <input id="count" type="number" placeholder="Current Case Count">
  <button onclick="addEntry()">Add Entry</button>
</div>

<div class="card">
  <h3>Log</h3>
  <div id="liveTime"><small></small></div>
  <div id="summary"><small>Waiting for run...</small></div>
  <div id="log" class="log"></div>
</div>

<div class="card">
  <h3>Last Run Info</h3>
  <div id="lastRun"><small>No previous run</small></div>
</div>

<button class="reset" onclick="endRun()">End Of Run</button>

<script>
let lines = [];
let currentLine = "";
let lastCount = null;
let material = "";
let runStartTime = null;
let lastRun = {}; // per line
let PASSWORD = ""; // stored once per session
const SERVER_URL = "https://cases.hytalesanarchy.com";

const lineSelect = document.getElementById("lineSelect");
const materialInput = document.getElementById("material");
const startCountInput = document.getElementById("startCount");
const timeInput = document.getElementById("time");
const countInput = document.getElementById("count");

// Ask for password once per session
function getPassword() {
    if (!PASSWORD) {
        PASSWORD = prompt("Enter password:");
    }
    return PASSWORD;
}

async function promptAndSend(entry, reset = false, line = "", action = "add") {
    if (!getPassword()) return alert("Password required");
    try {
        await fetch(`${SERVER_URL}/add`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ entry, reset, line: line || currentLine, action, password: PASSWORD })
        });
        loadLog();
    } catch {
        alert("Server unreachable");
    }
}

function startRun() {
    if (!currentLine) return alert("Select a line first");
    material = materialInput.value;
    lastCount = parseInt(startCountInput.value);
    if (!material || isNaN(lastCount)) return alert("Invalid setup");

    runStartTime = new Date();

    // Prevent duplicate Start
    const activeStartExists = document.querySelector("#log .log-entry b")?.innerText.includes("(+0)");
    if (activeStartExists) return alert("Run already started for this line");

    lastRun[currentLine] = { material, count: lastCount, start: runStartTime };
    promptAndSend({
        date: new Date().toDateString(),
        time: "Start",
        material,
        count: lastCount,
        diff: 0,
        line: currentLine
    });

    document.getElementById("summary").innerHTML =
        `<b>Material:</b> ${material}<br><b>Last Count:</b> ${lastCount}`;
}

async function endRun() {
    if (!runStartTime) return alert("No active run");
    const res = await fetch(`${SERVER_URL}/add`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ entry: {}, reset: false, line: currentLine, action: "endrun", password: getPassword() })
    });
    const data = await res.json();
    if (data.last_run) {
        lastRun[currentLine] = {
            material: data.last_run.material,
            count: data.last_run.count,
            start: new Date(data.last_run.start),
            end: new Date(data.last_run.end)
        };
    }
    material = ""; lastCount = null; runStartTime = null;
    document.getElementById("summary").innerHTML = "<small>Waiting for run...</small>";
    loadLog();
}

// On load, detect active run
async function loadLog() {
    try {
        const res = await fetch(`${SERVER_URL}/log.json?${Date.now()}`);
        const data = await res.json();
        populateLines(data);
        displayLog(data);
        updateLastRunInfo(data);

        // Detect active run: Start without corresponding end
        const activeStart = data.find(e => e.line === currentLine && e.time === "Start");
        if (activeStart) {
            runStartTime = new Date();
            lastCount = activeStart.count;
            material = activeStart.material;
            document.getElementById("summary").innerHTML =
                `<b>Material:</b> ${material}<br><b>Last Count:</b> ${lastCount}`;
        }

    } catch {
        document.getElementById("log").innerHTML = "<small>Server not reachable.</small>";
    }
}

function addEntry() {
    if (!currentLine || lastCount === null) return alert("Start a run first");
    const time = timeInput.value; const count = parseInt(countInput.value);
    if (!time || isNaN(count)) return;
    const diff = count - lastCount; lastCount = count;
    lastRun[currentLine].count = lastCount;
    promptAndSend({
        date: new Date().toDateString(),
        time, material, count, diff, line: currentLine
    });
    timeInput.value = ""; countInput.value = "";
    document.getElementById("summary").innerHTML =
        `<b>Material:</b> ${material}<br><b>Last Count:</b> ${lastCount}`;
}

function displayLog(data = []) {
    const logDiv = document.getElementById("log"); logDiv.innerHTML = "";
    if (!currentLine) return;
    data.filter(e => e.line === currentLine && !e.last_run).forEach(e => {
        const d = document.createElement("div");
        d.className = "log-entry";
        d.innerHTML = `${e.time} | ${e.material} | ${e.count} <b>(+${e.diff || 0})</b>`;
        logDiv.appendChild(d);
    });
}

function updateLastRunInfo(data = []) {
    if (!currentLine) return document.getElementById("lastRun").innerHTML = "<small>No previous run</small>";
    const lastRunEntry = data.find(e => e.line === currentLine && e.last_run);
    if (lastRunEntry) {
        const lr = lastRunEntry.last_run;
        lastRun[currentLine] = {
            material: lr.material,
            count: lr.count,
            start: new Date(lr.start),
            end: new Date(lr.end)
        };
    }
    if (lastRun[currentLine]) {
        const lr = lastRun[currentLine];
        document.getElementById("lastRun").innerHTML =
            `<b>Material:</b> ${lr.material}<br>
             <b>Last Count:</b> ${lr.count}<br>
             <b>Start:</b> ${lr.start.toLocaleString()}<br>
             <b>End:</b> ${lr.end.toLocaleString()}`;
    } else {
        document.getElementById("lastRun").innerHTML = "<small>No previous run</small>";
    }
}

setInterval(loadLog, 10000);
loadLog();
</script>
</body>
</html>
